{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { getSupportedInputTypes } from '@angular/cdk/platform';\nimport * as i4 from '@angular/cdk/text-field';\nimport { TextFieldModule } from '@angular/cdk/text-field';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Optional, Self, Inject, Input, NgModule } from '@angular/core';\nimport * as i2 from '@angular/forms';\nimport { Validators } from '@angular/forms';\nimport * as i3 from '@angular/material/core';\nimport { _ErrorStateTracker, MatCommonModule } from '@angular/material/core';\nimport * as i5 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD, MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nexport { MatError, MatFormField, MatHint, MatLabel, MatPrefix, MatSuffix } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\n\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nconst MAT_INPUT_VALUE_ACCESSOR = /*#__PURE__*/new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\nlet nextUniqueId = 0;\nlet MatInput = /*#__PURE__*/(() => {\n  class MatInput {\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n      // Browsers may not fire the blur event if the input is disabled too quickly.\n      // Reset from here to ensure that the element doesn't become stuck.\n      if (this.focused) {\n        this.focused = false;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id() {\n      return this._id;\n    }\n    set id(value) {\n      this._id = value || this._uid;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required() {\n      return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n    }\n    set required(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    /** Input type of the element. */\n    get type() {\n      return this._type;\n    }\n    set type(value) {\n      this._type = value || 'text';\n      this._validateType();\n      // When using Angular inputs, developers are no longer able to set the properties on the native\n      // input element. To ensure that bindings for `type` work, we need to sync the setter\n      // with the native property. Textarea elements don't support the type property or attribute.\n      if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n        this._elementRef.nativeElement.type = this._type;\n      }\n    }\n    /** An object used to control when error messages are shown. */\n    get errorStateMatcher() {\n      return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n      this._errorStateTracker.matcher = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value() {\n      return this._inputValueAccessor.value;\n    }\n    set value(value) {\n      if (value !== this.value) {\n        this._inputValueAccessor.value = value;\n        this.stateChanges.next();\n      }\n    }\n    /** Whether the element is readonly. */\n    get readonly() {\n      return this._readonly;\n    }\n    set readonly(value) {\n      this._readonly = coerceBooleanProperty(value);\n    }\n    /** Whether the input is in an error state. */\n    get errorState() {\n      return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n      this._errorStateTracker.errorState = value;\n    }\n    constructor(_elementRef, _platform, ngControl, parentForm, parentFormGroup, defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone,\n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    _formField) {\n      this._elementRef = _elementRef;\n      this._platform = _platform;\n      this.ngControl = ngControl;\n      this._autofillMonitor = _autofillMonitor;\n      this._formField = _formField;\n      this._uid = `mat-input-${nextUniqueId++}`;\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n      this.focused = false;\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n      this.stateChanges = new Subject();\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n      this.controlType = 'mat-input';\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n      this.autofilled = false;\n      this._disabled = false;\n      this._type = 'text';\n      this._readonly = false;\n      this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(t => getSupportedInputTypes().has(t));\n      this._iOSKeyupListener = event => {\n        const el = event.target;\n        // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n        // indicate different things. If the value is 0, it means that the caret is at the start\n        // of the input, whereas a value of `null` means that the input doesn't support\n        // manipulating the selection range. Inputs that don't support setting the selection range\n        // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n        // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n          // Note: Just setting `0, 0` doesn't fix the issue. Setting\n          // `1, 1` fixes it for the first time that you type text and\n          // then hold delete. Toggling to `1, 1` and then back to\n          // `0, 0` seems to completely fix it.\n          el.setSelectionRange(1, 1);\n          el.setSelectionRange(0, 0);\n        }\n      };\n      const element = this._elementRef.nativeElement;\n      const nodeName = element.nodeName.toLowerCase();\n      // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n      this._inputValueAccessor = inputValueAccessor || element;\n      this._previousNativeValue = this.value;\n      // Force setter to be called in case id was not specified.\n      this.id = this.id;\n      // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n      // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n      // exists on iOS, we only bother to install the listener on iOS.\n      if (_platform.IOS) {\n        ngZone.runOutsideAngular(() => {\n          _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n        });\n      }\n      this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, ngControl, parentFormGroup, parentForm, this.stateChanges);\n      this._isServer = !this._platform.isBrowser;\n      this._isNativeSelect = nodeName === 'select';\n      this._isTextarea = nodeName === 'textarea';\n      this._isInFormField = !!_formField;\n      if (this._isNativeSelect) {\n        this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n      }\n    }\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n          this.autofilled = event.isAutofilled;\n          this.stateChanges.next();\n        });\n      }\n    }\n    ngOnChanges() {\n      this.stateChanges.next();\n    }\n    ngOnDestroy() {\n      this.stateChanges.complete();\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n      }\n      if (this._platform.IOS) {\n        this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n      }\n    }\n    ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n        // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n        // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n        // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n        // disabled.\n        if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n          this.disabled = this.ngControl.disabled;\n          this.stateChanges.next();\n        }\n      }\n      // We need to dirty-check the native element's value, because there are some cases where\n      // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n      // updating the value using `emitEvent: false`).\n      this._dirtyCheckNativeValue();\n      // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n      // present or not depends on a query which is prone to \"changed after checked\" errors.\n      this._dirtyCheckPlaceholder();\n    }\n    /** Focuses the input. */\n    focus(options) {\n      this._elementRef.nativeElement.focus(options);\n    }\n    /** Refreshes the error state of the input. */\n    updateErrorState() {\n      this._errorStateTracker.updateErrorState();\n    }\n    /** Callback for the cases where the focused state of the input changes. */\n    _focusChanged(isFocused) {\n      if (isFocused !== this.focused) {\n        this.focused = isFocused;\n        this.stateChanges.next();\n      }\n    }\n    _onInput() {\n      // This is a noop function and is used to let Angular know whenever the value changes.\n      // Angular will run a new change detection each time the `input` event has been dispatched.\n      // It's necessary that Angular recognizes the value change, because when floatingLabel\n      // is set to false and Angular forms aren't used, the placeholder won't recognize the\n      // value changes and will not disappear.\n      // Listening to the input event wouldn't be necessary when the input is using the\n      // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /** Does some manual dirty checking on the native input `value` property. */\n    _dirtyCheckNativeValue() {\n      const newValue = this._elementRef.nativeElement.value;\n      if (this._previousNativeValue !== newValue) {\n        this._previousNativeValue = newValue;\n        this.stateChanges.next();\n      }\n    }\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n    _dirtyCheckPlaceholder() {\n      const placeholder = this._getPlaceholder();\n      if (placeholder !== this._previousPlaceholder) {\n        const element = this._elementRef.nativeElement;\n        this._previousPlaceholder = placeholder;\n        placeholder ? element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n      }\n    }\n    /** Gets the current placeholder of the form field. */\n    _getPlaceholder() {\n      return this.placeholder || null;\n    }\n    /** Make sure the input is a supported type. */\n    _validateType() {\n      if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatInputUnsupportedTypeError(this._type);\n      }\n    }\n    /** Checks whether the input type is one of the types that are never empty. */\n    _isNeverEmpty() {\n      return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /** Checks whether the input is invalid based on the native validation. */\n    _isBadInput() {\n      // The `validity` property won't be present on platform-server.\n      let validity = this._elementRef.nativeElement.validity;\n      return validity && validity.badInput;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty() {\n      return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n      if (this._isNativeSelect) {\n        // For a single-selection `<select>`, the label should float when the selected option has\n        // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n        // overlapping the label with the options.\n        const selectElement = this._elementRef.nativeElement;\n        const firstOption = selectElement.options[0];\n        // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n        // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n        return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n      } else {\n        return this.focused || !this.empty;\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n      if (ids.length) {\n        this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n      } else {\n        this._elementRef.nativeElement.removeAttribute('aria-describedby');\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n      // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n      // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n      // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n      if (!this.focused) {\n        this.focus();\n      }\n    }\n    /** Whether the form control is a native select that is displayed inline. */\n    _isInlineSelect() {\n      const element = this._elementRef.nativeElement;\n      return this._isNativeSelect && (element.multiple || element.size > 1);\n    }\n    static {\n      this.ɵfac = function MatInput_Factory(t) {\n        return new (t || MatInput)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2.NgControl, 10), i0.ɵɵdirectiveInject(i2.NgForm, 8), i0.ɵɵdirectiveInject(i2.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i3.ErrorStateMatcher), i0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), i0.ɵɵdirectiveInject(i4.AutofillMonitor), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(MAT_FORM_FIELD, 8));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: MatInput,\n        selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n        hostAttrs: [1, \"mat-mdc-input-element\"],\n        hostVars: 18,\n        hostBindings: function MatInput_HostBindings(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n              return ctx._focusChanged(true);\n            })(\"blur\", function MatInput_blur_HostBindingHandler() {\n              return ctx._focusChanged(false);\n            })(\"input\", function MatInput_input_HostBindingHandler() {\n              return ctx._onInput();\n            });\n          }\n          if (rf & 2) {\n            i0.ɵɵhostProperty(\"id\", ctx.id)(\"disabled\", ctx.disabled)(\"required\", ctx.required);\n            i0.ɵɵattribute(\"name\", ctx.name || null)(\"readonly\", ctx.readonly && !ctx._isNativeSelect || null)(\"aria-invalid\", ctx.empty && ctx.required ? null : ctx.errorState)(\"aria-required\", ctx.required)(\"id\", ctx.id);\n            i0.ɵɵclassProp(\"mat-input-server\", ctx._isServer)(\"mat-mdc-form-field-textarea-control\", ctx._isInFormField && ctx._isTextarea)(\"mat-mdc-form-field-input-control\", ctx._isInFormField)(\"mdc-text-field__input\", ctx._isInFormField)(\"mat-mdc-native-select-inline\", ctx._isInlineSelect());\n          }\n        },\n        inputs: {\n          disabled: \"disabled\",\n          id: \"id\",\n          placeholder: \"placeholder\",\n          name: \"name\",\n          required: \"required\",\n          type: \"type\",\n          errorStateMatcher: \"errorStateMatcher\",\n          userAriaDescribedBy: [i0.ɵɵInputFlags.None, \"aria-describedby\", \"userAriaDescribedBy\"],\n          value: \"value\",\n          readonly: \"readonly\"\n        },\n        exportAs: [\"matInput\"],\n        standalone: true,\n        features: [i0.ɵɵProvidersFeature([{\n          provide: MatFormFieldControl,\n          useExisting: MatInput\n        }]), i0.ɵɵNgOnChangesFeature]\n      });\n    }\n  }\n  return MatInput;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatInputModule = /*#__PURE__*/(() => {\n  class MatInputModule {\n    static {\n      this.ɵfac = function MatInputModule_Factory(t) {\n        return new (t || MatInputModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: MatInputModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n        imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule]\n      });\n    }\n  }\n  return MatInputModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };","map":{"version":3,"names":["coerceBooleanProperty","i1","getSupportedInputTypes","i4","TextFieldModule","i0","InjectionToken","Directive","Optional","Self","Inject","Input","NgModule","i2","Validators","i3","_ErrorStateTracker","MatCommonModule","i5","MAT_FORM_FIELD","MatFormFieldControl","MatFormFieldModule","MatError","MatFormField","MatHint","MatLabel","MatPrefix","MatSuffix","Subject","getMatInputUnsupportedTypeError","type","Error","MAT_INPUT_VALUE_ACCESSOR","MAT_INPUT_INVALID_TYPES","nextUniqueId","MatInput","disabled","_disabled","value","focused","stateChanges","next","id","_id","_uid","required","_required","ngControl","control","hasValidator","_type","_validateType","_isTextarea","has","_elementRef","nativeElement","errorStateMatcher","_errorStateTracker","matcher","_inputValueAccessor","readonly","_readonly","errorState","constructor","_platform","parentForm","parentFormGroup","defaultErrorStateMatcher","inputValueAccessor","_autofillMonitor","ngZone","_formField","controlType","autofilled","_neverEmptyInputTypes","filter","t","_iOSKeyupListener","event","el","target","selectionStart","selectionEnd","setSelectionRange","element","nodeName","toLowerCase","_previousNativeValue","IOS","runOutsideAngular","addEventListener","_isServer","isBrowser","_isNativeSelect","_isInFormField","multiple","ngAfterViewInit","monitor","subscribe","isAutofilled","ngOnChanges","ngOnDestroy","complete","stopMonitoring","removeEventListener","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","_onInput","newValue","placeholder","_getPlaceholder","_previousPlaceholder","setAttribute","removeAttribute","indexOf","ngDevMode","_isNeverEmpty","_isBadInput","validity","badInput","empty","shouldLabelFloat","selectElement","firstOption","selectedIndex","label","setDescribedByIds","ids","length","join","onContainerClick","_isInlineSelect","size","ɵfac","MatInput_Factory","ɵɵdirectiveInject","ElementRef","Platform","NgControl","NgForm","FormGroupDirective","ErrorStateMatcher","AutofillMonitor","NgZone","ɵdir","ɵɵdefineDirective","selectors","hostAttrs","hostVars","hostBindings","MatInput_HostBindings","rf","ctx","ɵɵlistener","MatInput_focus_HostBindingHandler","MatInput_blur_HostBindingHandler","MatInput_input_HostBindingHandler","ɵɵhostProperty","ɵɵattribute","name","ɵɵclassProp","inputs","userAriaDescribedBy","ɵɵInputFlags","None","exportAs","standalone","features","ɵɵProvidersFeature","provide","useExisting","ɵɵNgOnChangesFeature","MatInputModule","MatInputModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports"],"sources":["C:/Users/krava/OneDrive/Desktop/angular_cards/node_modules/@angular/material/fesm2022/input.mjs"],"sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { getSupportedInputTypes } from '@angular/cdk/platform';\nimport * as i4 from '@angular/cdk/text-field';\nimport { TextFieldModule } from '@angular/cdk/text-field';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Optional, Self, Inject, Input, NgModule } from '@angular/core';\nimport * as i2 from '@angular/forms';\nimport { Validators } from '@angular/forms';\nimport * as i3 from '@angular/material/core';\nimport { _ErrorStateTracker, MatCommonModule } from '@angular/material/core';\nimport * as i5 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD, MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nexport { MatError, MatFormField, MatHint, MatLabel, MatPrefix, MatSuffix } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\n\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nconst MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit',\n];\nlet nextUniqueId = 0;\nclass MatInput {\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n        if (this.focused) {\n            this.focused = false;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id() {\n        return this._id;\n    }\n    set id(value) {\n        this._id = value || this._uid;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required() {\n        return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n    }\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n    }\n    /** Input type of the element. */\n    get type() {\n        return this._type;\n    }\n    set type(value) {\n        this._type = value || 'text';\n        this._validateType();\n        // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n        if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n            this._elementRef.nativeElement.type = this._type;\n        }\n    }\n    /** An object used to control when error messages are shown. */\n    get errorStateMatcher() {\n        return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n        this._errorStateTracker.matcher = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value() {\n        return this._inputValueAccessor.value;\n    }\n    set value(value) {\n        if (value !== this.value) {\n            this._inputValueAccessor.value = value;\n            this.stateChanges.next();\n        }\n    }\n    /** Whether the element is readonly. */\n    get readonly() {\n        return this._readonly;\n    }\n    set readonly(value) {\n        this._readonly = coerceBooleanProperty(value);\n    }\n    /** Whether the input is in an error state. */\n    get errorState() {\n        return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n        this._errorStateTracker.errorState = value;\n    }\n    constructor(_elementRef, _platform, ngControl, parentForm, parentFormGroup, defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone, \n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    _formField) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this.ngControl = ngControl;\n        this._autofillMonitor = _autofillMonitor;\n        this._formField = _formField;\n        this._uid = `mat-input-${nextUniqueId++}`;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        this.focused = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        this.stateChanges = new Subject();\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        this.controlType = 'mat-input';\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        this.autofilled = false;\n        this._disabled = false;\n        this._type = 'text';\n        this._readonly = false;\n        this._neverEmptyInputTypes = [\n            'date',\n            'datetime',\n            'datetime-local',\n            'month',\n            'time',\n            'week',\n        ].filter(t => getSupportedInputTypes().has(t));\n        this._iOSKeyupListener = (event) => {\n            const el = event.target;\n            // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n            // indicate different things. If the value is 0, it means that the caret is at the start\n            // of the input, whereas a value of `null` means that the input doesn't support\n            // manipulating the selection range. Inputs that don't support setting the selection range\n            // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n            // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n            if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n                // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                // `1, 1` fixes it for the first time that you type text and\n                // then hold delete. Toggling to `1, 1` and then back to\n                // `0, 0` seems to completely fix it.\n                el.setSelectionRange(1, 1);\n                el.setSelectionRange(0, 0);\n            }\n        };\n        const element = this._elementRef.nativeElement;\n        const nodeName = element.nodeName.toLowerCase();\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        this._inputValueAccessor = inputValueAccessor || element;\n        this._previousNativeValue = this.value;\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (_platform.IOS) {\n            ngZone.runOutsideAngular(() => {\n                _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n            });\n        }\n        this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, ngControl, parentFormGroup, parentForm, this.stateChanges);\n        this._isServer = !this._platform.isBrowser;\n        this._isNativeSelect = nodeName === 'select';\n        this._isTextarea = nodeName === 'textarea';\n        this._isInFormField = !!_formField;\n        if (this._isNativeSelect) {\n            this.controlType = element.multiple\n                ? 'mat-native-select-multiple'\n                : 'mat-native-select';\n        }\n    }\n    ngAfterViewInit() {\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n                this.autofilled = event.isAutofilled;\n                this.stateChanges.next();\n            });\n        }\n    }\n    ngOnChanges() {\n        this.stateChanges.next();\n    }\n    ngOnDestroy() {\n        this.stateChanges.complete();\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n        if (this._platform.IOS) {\n            this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n        }\n    }\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n            // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n            // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n            // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n            // disabled.\n            if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n                this.disabled = this.ngControl.disabled;\n                this.stateChanges.next();\n            }\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n        // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n        // present or not depends on a query which is prone to \"changed after checked\" errors.\n        this._dirtyCheckPlaceholder();\n    }\n    /** Focuses the input. */\n    focus(options) {\n        this._elementRef.nativeElement.focus(options);\n    }\n    /** Refreshes the error state of the input. */\n    updateErrorState() {\n        this._errorStateTracker.updateErrorState();\n    }\n    /** Callback for the cases where the focused state of the input changes. */\n    _focusChanged(isFocused) {\n        if (isFocused !== this.focused) {\n            this.focused = isFocused;\n            this.stateChanges.next();\n        }\n    }\n    _onInput() {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /** Does some manual dirty checking on the native input `value` property. */\n    _dirtyCheckNativeValue() {\n        const newValue = this._elementRef.nativeElement.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    }\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n    _dirtyCheckPlaceholder() {\n        const placeholder = this._getPlaceholder();\n        if (placeholder !== this._previousPlaceholder) {\n            const element = this._elementRef.nativeElement;\n            this._previousPlaceholder = placeholder;\n            placeholder\n                ? element.setAttribute('placeholder', placeholder)\n                : element.removeAttribute('placeholder');\n        }\n    }\n    /** Gets the current placeholder of the form field. */\n    _getPlaceholder() {\n        return this.placeholder || null;\n    }\n    /** Make sure the input is a supported type. */\n    _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    }\n    /** Checks whether the input type is one of the types that are never empty. */\n    _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /** Checks whether the input is invalid based on the native validation. */\n    _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        let validity = this._elementRef.nativeElement.validity;\n        return validity && validity.badInput;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty() {\n        return (!this._isNeverEmpty() &&\n            !this._elementRef.nativeElement.value &&\n            !this._isBadInput() &&\n            !this.autofilled);\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n        if (this._isNativeSelect) {\n            // For a single-selection `<select>`, the label should float when the selected option has\n            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n            // overlapping the label with the options.\n            const selectElement = this._elementRef.nativeElement;\n            const firstOption = selectElement.options[0];\n            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n            return (this.focused ||\n                selectElement.multiple ||\n                !this.empty ||\n                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label));\n        }\n        else {\n            return this.focused || !this.empty;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n        if (ids.length) {\n            this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n        }\n        else {\n            this._elementRef.nativeElement.removeAttribute('aria-describedby');\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n            this.focus();\n        }\n    }\n    /** Whether the form control is a native select that is displayed inline. */\n    _isInlineSelect() {\n        const element = this._elementRef.nativeElement;\n        return this._isNativeSelect && (element.multiple || element.size > 1);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatInput, deps: [{ token: i0.ElementRef }, { token: i1.Platform }, { token: i2.NgControl, optional: true, self: true }, { token: i2.NgForm, optional: true }, { token: i2.FormGroupDirective, optional: true }, { token: i3.ErrorStateMatcher }, { token: MAT_INPUT_VALUE_ACCESSOR, optional: true, self: true }, { token: i4.AutofillMonitor }, { token: i0.NgZone }, { token: MAT_FORM_FIELD, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatInput, isStandalone: true, selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\", inputs: { disabled: \"disabled\", id: \"id\", placeholder: \"placeholder\", name: \"name\", required: \"required\", type: \"type\", errorStateMatcher: \"errorStateMatcher\", userAriaDescribedBy: [\"aria-describedby\", \"userAriaDescribedBy\"], value: \"value\", readonly: \"readonly\" }, host: { listeners: { \"focus\": \"_focusChanged(true)\", \"blur\": \"_focusChanged(false)\", \"input\": \"_onInput()\" }, properties: { \"class.mat-input-server\": \"_isServer\", \"class.mat-mdc-form-field-textarea-control\": \"_isInFormField && _isTextarea\", \"class.mat-mdc-form-field-input-control\": \"_isInFormField\", \"class.mdc-text-field__input\": \"_isInFormField\", \"class.mat-mdc-native-select-inline\": \"_isInlineSelect()\", \"id\": \"id\", \"disabled\": \"disabled\", \"required\": \"required\", \"attr.name\": \"name || null\", \"attr.readonly\": \"readonly && !_isNativeSelect || null\", \"attr.aria-invalid\": \"(empty && required) ? null : errorState\", \"attr.aria-required\": \"required\", \"attr.id\": \"id\" }, classAttribute: \"mat-mdc-input-element\" }, providers: [{ provide: MatFormFieldControl, useExisting: MatInput }], exportAs: [\"matInput\"], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatInput, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n                    exportAs: 'matInput',\n                    host: {\n                        'class': 'mat-mdc-input-element',\n                        // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n                        // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n                        // this MDC equivalent input.\n                        '[class.mat-input-server]': '_isServer',\n                        '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n                        '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n                        '[class.mdc-text-field__input]': '_isInFormField',\n                        '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\n                        // the native input element. Otherwise property bindings for those don't work.\n                        '[id]': 'id',\n                        '[disabled]': 'disabled',\n                        '[required]': 'required',\n                        '[attr.name]': 'name || null',\n                        '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n                        // Only mark the input as invalid for assistive technology if it has a value since the\n                        // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n                        '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n                        '[attr.aria-required]': 'required',\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\n                        // the native input element. Otherwise property bindings for those don't work.\n                        '[attr.id]': 'id',\n                        '(focus)': '_focusChanged(true)',\n                        '(blur)': '_focusChanged(false)',\n                        '(input)': '_onInput()',\n                    },\n                    providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.Platform }, { type: i2.NgControl, decorators: [{\n                    type: Optional\n                }, {\n                    type: Self\n                }] }, { type: i2.NgForm, decorators: [{\n                    type: Optional\n                }] }, { type: i2.FormGroupDirective, decorators: [{\n                    type: Optional\n                }] }, { type: i3.ErrorStateMatcher }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Self\n                }, {\n                    type: Inject,\n                    args: [MAT_INPUT_VALUE_ACCESSOR]\n                }] }, { type: i4.AutofillMonitor }, { type: i0.NgZone }, { type: i5.MatFormField, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_FORM_FIELD]\n                }] }], propDecorators: { disabled: [{\n                type: Input\n            }], id: [{\n                type: Input\n            }], placeholder: [{\n                type: Input\n            }], name: [{\n                type: Input\n            }], required: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], errorStateMatcher: [{\n                type: Input\n            }], userAriaDescribedBy: [{\n                type: Input,\n                args: ['aria-describedby']\n            }], value: [{\n                type: Input\n            }], readonly: [{\n                type: Input\n            }] } });\n\nclass MatInputModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: MatInputModule, imports: [MatCommonModule, MatFormFieldModule, MatInput], exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatInputModule, imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatInputModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, MatFormFieldModule, MatInput],\n                    exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}